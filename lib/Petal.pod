=head1 NAME

Petal - Perl Template Attribute Language - TAL for Perl!


=head1 SYNOPSIS

in your Perl code:

  use Petal;
  my $template = new Petal ('foo.xhtml');
  print $template->process (bar => 'BAZ');


in foo.xhtml

  <html xmlns:tal="http://purl.org/petal/1.0/">
    <body tal:content="foo">Dummy Content</body>
  </html>


=head1 SUMMARY

Petal is a XML based templating engine that is able to process any
kind of XML. HTML parsing and XHTML is also supported.

Because Petal borrows a lot of good ideas from the Zope Page Templates
TAL specification, it is very well suited for the creation of truly WYSIWYG
XHTML editable templates.

The idea is to enforce even further the separation of logic and
presentation. With Petal, graphic designers who use their favorite
WYSIWYG editor can easily edit templates without having to worry about
the loops and ifs which happen behind the scenes.

Besides, you can safely send the result of their work through HTML tidy
to make sure that you always output neat, standard compliant, valid XML
pages.


=head1 NAMESPACE

Although this is not mandatory, Petal templates should include use the namespace
http://purl.org/petal/1.0/. Example:

    <html xml:lang="en"
          lang="en-"
          xmlns="http://www.w3.org/1999/xhtml"
          xmlns:tal="http://purl.org/petal/1.0/">

      Blah blah blah...
      Content of the file
      More blah blah...
    </html>

If you do not specify the namespace, Petal will by default try to use the 'petal:'
prefix. However, in all the examples of this POD we'll use the 'tal:' prefix to
avoid too much typing :-)


=head1 KICKSTART

Let's say you have the following Perl code:

    use Petal;
    local $Petal::OUTPUT = 'XHTML';
    my $template = new Petal ('foo.xhtml');
    template->process ( my_var => my_var() );

some_object() is a subroutine that returns some kind of object, may it be a scalar,
object, array referebce or hash reference. Let's see what we can do...


=head2 v1, prototype

    <html xmlns:tal="http://purl.org/petal/1.0/">
      <body>
        This is the variable 'my_var' : ${my_var}.
      </body>
    </html>


And if 'my_var' contained 'Hello World', Petal would have outputted:

    <html>
      <body>
        This is the variable 'my_var' : Hello World.
      </body>
    </html>


Now let's say that 'my_var' is actually an object with a method
hello_world() that returns 'Hello World'. To output the same
result, you would write:

    This is the variable 'my_var' : ${my_var/hello_world}.


Now let's say that 'my_var' is a hash reference as follows:

    $VAR1 = { hello_world => 'Hello, World' }


To output the same result, you would write:

    This is the variable 'my_var' : ${my_var/hello_world}.


=head2 v2, WYSIWYG friendly.

The problem with the page above is that when you edit it with
a WYSIWYG editor, or simply open it in your browser, you see:

    This is the variable 'my_var' : ${my_var/hello_world}.

Ideally you don't want your graphic designers to worry about
variable names... and that's where TAL kicks in. Using TAL
you can do:

    This is the variable 'my_var' :
    <span tal:replace="my_var/hello_world">Hola, Mundo!</span>

Now you can open your template in any WYSIWYG tool (mozilla
composer, frontpage, dreamweaver, adobe golive...) and work
without risking to change the syntax to a syntax that is
incorrect.

TAL lets you do conditions, loops and everything you need, but
we'll see that later.


=head2 v3, object-oriented version!

Let's now say that 'my_var' is actually an object with
a method hello_world() that returns 'Hello World'. To output
the same result, your line:

    <span tal:replace="my_var/hello_world">Hola, Mundo!</span>

Would become:

    <span tal:replace="my_var/hello_world">Hola, Mundo!</span>

Look carefully at those two lines. That's right. There are
exactly identical. Petal lets you access hashes and objects in
an entirely transparent way.

This high level of polymorphism means that in most cases you can
maintain your code, swap hashes for objects, and not change a
single line of your template code.


=head2 v4, personalizable

Now let's say that your method some_object() can take an optional
argument so that $my_var->hello_world ('Jack') returns 'Hello Jack'.

You would write:

    <span tal:replace="my_var/hello_world 'Jack'">Hola, Mundo!</span>


Optionally, you can get rid of the quotes by using double dashes:

    <span tal:replace="my_var/hello_world --Jack">Hola, Mundo!</span>


So you can pass parameters to methods using double dashes or quotes.
Now let us say that your my_var object also has a method current_user()
that returns the current user real name. You can do:

    <span tal:replace="my_var/hello_world my_var/current_user">Hola, Mundo!</span>


TRAP:

You cannot write nested expressions such as:

    ${my_var/hello_world ${my_var/current_user}}

It won't work. Don't do it.


=head2 v5, internationalized

This feature has been added in Petal 0.91. Let's say that you have
a directory called hello-world with the following files:

    hello_world/en.xhtml
    hello_world/fr.xhtml
    hello_world/es.xhtml

You can use Petal as follows in your Perl code:

    use Petal;
    local $Petal::OUTPUT = 'XHTML';
    my $template = new Petal (
        file => 'hello_world',
        lang => 'fr-CA',
    );
    print $template->process ( my_var => my_var() );

What will happen is that the $template object will try to find a
file named 'fr-CA', then 'fr', then will default to 'en'. It should
work fine for includes, too!


=head1 OPTIONS

The following options alter the way Petal works.


=head2 $Petal::INPUT

Currently acceptable values are

  'XML'   - Petal will use XML::Parser to parse the template
  'HTML'  - Petal will use HTML::TreeBuilder to parse the template
  'XHTML' - Alias for 'HTML'

This variable defaults to 'XML'.

Example:

  local $Petal::INPUT = 'XHTML';


=head2 $Petal::OUTPUT

Currently acceptable values are

  'XML'   - Petal will use XML::Parser to parse the template
  'HTML'  - Petal will use HTML::TreeBuilder to parse the template
  'XHTML' - Alias for 'HTML'

This variable defaults to 'XML'.

Example:

  local $Petal::OUTPUT = 'XHTML';


=head2 $Petal::TAINT

If set to TRUE, makes perl taint mode happy. Defaults to FALSE.


=head2 @Petal::BASE_DIR

Sets the base directories in which Petal looks for templates.

Petal will try to fetch the template file starting from the beginning of the
list until it finds one base directory which has the requested file.

Defaults to ('.').

Example:

  local @Petal::BASE_DIR = ('.', 'templates', '/www/templates');


=head2 $Petal::DISK_CACHE

If set to FALSE, Petal will not use the Petal::Cache::Disk module. Defaults to TRUE.


=head2 $Petal::MEMORY_CACHE

If set to FALSE, Petal will not use the Petal::Cache::Memory module. Defaults to TRUE.


=head2 $Petal::MAX_INCLUDES

$MAX_INCLUDES - Maximum number of recursive includes before Petal stops processing.
This is to prevent from accidental infinite recursions.

Defaults to 30.


=head2 $Petal::LANGUAGE

Fallback language when using Petal in multi-language mode.
Defaults to 'en'.

Example:

    local $Petal::LANGUAGE = 'fr';


=head1 TAL SYNTAX

This functionality is directly and shamelessly stolen from the excellent
TAL specification, which is available there:

http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL.


=head2 define

Abstract

  <tag tal:define="variable_name EXPRESSION">

Evaluates EXPRESSION and assigns the returned value
to variable_name.

Example

  <!-- sets document/title to 'title' -->
  <span tal:define="title document/title">

Why?

This can be useful if you have a 'very/very/long/expression'.
You can set it to let's say 'vvle' and then use 'vvle' instead
of using 'very/very/long/expression'.


=head2 condition (ifs)

Abstract

  <tag tal:condition="true:EXPRESSION">
     blah blah blah
  </tag>

Example

  <span tal:condition="true:user/is_authenticated">
    Yo, authenticated!
  </span>

Why?

Conditions can be used to display something if an expression
is true. They can also be used to check that a list exists
before attempting to loop through it.


=head2 repeat (loops)

Abstract

  <tag tal:repeat="element_name EXPRESSION">
     blah blah blah
  </tag>

Example

  <li tal:repeat="user system/user_list">$user/real_name</li>

Why?

Repeat statements are used to loop through a list of values,
typically to display the resulting records of a database query.


=head2 attributes

Abstract

  <tag tal:attributes="attr1 EXPRESSION_1; attr2 EXPRESSION_2"; ...">
     blah blah blah
  </tag>

Example

  <a href="http://www.gianthard.com"
     lang="en-gb"
     tal:attributes="href document/href_relative; lang document/lang">

Why?

Attributes statements can be used to replace the values of the attributes
which belong to the tag in which they are used.


=head2 content

Abstract

  <tag tal:content="EXPRESSION">Dummy Data To Replace With EXPRESSION</tag>

By default, the characters '<', '>', '"' and '&' are encoded to the entities
'&lt', '&gt;', '&quot;' and '&amp;' respectively. If you don't want them to
(because the result of your expression is already encoded) you have to use
the 'structure' keyword.

Example

  <span tal:content="title">Dummy Title</span>

  <span tal:content="structure some_modifier:some/encoded/variable">
     blah blah blah
  </span>

Why?

Lets you replace the contents of a tag with whatever value the evaluation of
EXPRESSION returned. This is handy because you can fill your XML/XHTML templates
with dummy content which will make them usable in a WYSIWYG tool.


=head2 replace

Abstract

  <tag tal:replace="EXPRESSION">
    This time the entire tag is replaced
    rather than just the content!
  </tag>

Example

  <span tal:replace="title">Dummy Title</span>

Why?

Similar reasons to 'contents'. Note however that 'tal:content' and
'tal:replace' are *NOT* aliases. The former will replace the contents
of the tag, while the latter will replace the whole tag.

Indeed you cannot use tal:content and tal:replace in the same tag.


=head2 omit-tag

Abstract

  <tag tal:omit-tag="EXPRESSION">Some contents</tag>

Example

  <b tal:omit-tag="not:bold">I may not be bold.</b>

If 'not:bold' is evaluated as TRUE, then the <b> tag will be omited.
If 'not:bold' is evaluated as FALSE, then the <b> tag will stay in place.

Why?

omit-tag statements can be used to leave the contents of a tag in place
while omitting the surrounding start and end tags if the expression which
is evaluated is TRUE.


=head2 on-error

Abstract

  <tag on-error="EXPRESSION">...</tag>

Example

  <p on-error="string:Cannot access object/method!!">
    $object/method
  </p>

Why?

When Petal encounters an error, it usually dies with some obscure error
message. The on-error statement lets you trap the error and replace it
with a proper error message.


=head2 using multiple statements

You can do things like:

  <p tal:define="children document/children"
     tal:condition="children"
     tal:repeat="child children"
     tal:attributes="lang child/lang; xml:lang child/lang"
     tal:content="child/data"
     tal:on-error="string:Ouch!">Some Dummy Content</p>

Given the fact that XML attributes are not ordered, withing the same tag
statements will be executed in the following order: define, condition,
repeat, (attributes, content) or (replace) or (omit-tag, content).


=head2 aliases

On top of all that, for people who are lazy at typing the following
aliases are provided (although I would recommend sticking to the
defaults):

  * tal:define     - tal:def, tal:set
  * tal:condition  - tal:if
  * tal:repeat     - tal:for, tal:loop, tal:foreach
  * tal:attributes - tal:att, tal:attr, tal:atts
  * tal:content    - tal:inner
  * tal:replace    - tal:outer


TRAP:

Don't forget that the default prefix is petal: NOT tal:, until
you set the petal namespace in your HTML or XML document as follows:

<html xmlns:tal="http://purl.org/petal/1.0/">


=head1 INCLUDES

Let's say that your base directory is '/www/projects/foo/templates',
and you're editing '/www/projects/foo/templates/hello/index.html'.

From there you want to include '/www/projects/foo/templates/includes/header.html'


=head2 general syntax

You can use a subset of the XInclude syntax as follows:

  <body xmlns:xi="http://www.w3.org/2001/XInclude">
    <xi:include href="/includes/header.html" />
  </body>


For backwards compatibility reasons, you can omit the first slash, i.e.

  <xi:include href="includes/header.html" />


=head2 relative paths

If you'd rather use a path which is relative to the template itself rather
than the base directory, you can do it but the path needs to start with a dot,
i.e.

  <xi:include href="../includes/header.html" />

  <xi:include href="./subdirectory/foo.xml" />

etc.


=head2 limitations

The 'href' parameter does not support URIs, no other tag than
xi:include is supported, and no other directive than the 'href'
parameter is supported at the moment.

Also note that contrarily to the XInclude specification Petal DOES
allow recursive includes up to $Petal::MAX_INCLUDES. This behavior
is very useful when designing templates to display data which can
be recursive such as sitemaps, database cursors, fibonacci suites,
etc.

You can use ONLY the following Petal directives with Xinclude tags:

  * on-error
  * define
  * condition
  * repeat

replace, content, omit-tag and attributes are NOT supported in
conjunction with XIncludes.


=head1 EXPRESSIONS AND MODIFIERS

Petal has the ability to bind template variables to the following Perl
datatypes: scalars, lists, hash, arrays and objects. The article describes
the syntax which is used to access these from Petal templates.

In the following examples, we'll assume that the template is used as follows:

  my $hashref = some_complex_data_structure();
  my $template = new Petal ('foo.xml');
  print $template->process ( $hashref );

Then we will show how the Petal Expression Syntax maps to the Perl way of
accessing these values.  


=head2 accessing scalar values

Perl expression

  $hashref->{'some_value'};

Petal expression

  some_value

Example

  <!--? Replaces Hello, World with the contents of
        $hashref->{'some_value'}
  -->
  <span tal:replace="some_value">Hello, World</span>


=head2 accessing hashes & arrays

Perl expression

  $hashref->{'some_hash'}->{'a_key'};

Petal expression

  some_hash/a_key

Example

  <!--? Replaces Hello, World with the contents
        of $hashref->{'some_hash'}->{'a_key'}
  -->
  <span tal:replace="some_hash/a_key">Hello, World</span>


Perl expression

  $hashref->{'some_array'}->[12]

Petal expression

  some_array/12

Example

  <!-- Replaces Hello, World with the contents
       of $hashref->{'some_array'}->[12]
  -->
  <span tal:replace="some_array/12">Hello, World</span>

Note: You're more likely to want to loop through arrays:

  <!-- Loops trough the array and displays each values -->
  <ul tal:condition="some_array">
    <li tal:repeat="value some_array"
        tal:content="value">Hello, World</li>
  </ul>


=head2 accessing object methods

Perl expressions

  1. $hashref->{'some_object'}->some_method();
  2. $hashref->{'some_object'}->some_method ('foo', 'bar');
  3. $hashref->{'some_object'}->some_method ($hashref->{'some_variable')  

Petal expressions

  1. some_object/some_method
  2a. some_object/some_method 'foo' 'bar'
  2b. some_object/some_method "foo" "bar"
  2c. some_object/some_method --foo --bar
  3. some_object/some_method some_variable

Note that the syntax as described in 2c works only if you use strings
which do not contain spaces.

Example

  <p>
    <span tal:replace="value1">2</span> times
    <span tal:replace="value2">2</span> equals
    <span tal:replace="math_object/multiply value1 value2">4</span>
  </p>
    

=head2 composing

Petal lets you traverse any data structure, i.e.

Perl expression

  $hashref->{'some_object'}
          ->some_method()
          ->{'key2'}
          ->some_other_method ( 'foo', $hash->{bar} );

Petal expression

  some_object/some_method/key2/some_other_method --foo bar


=head2 true:EXPRESSION

  If EXPRESSION returns an array reference
    If this array reference has at least one element
      Returns TRUE
    Else
      Returns FALSE

  Else
    If EXPRESSION returns a TRUE value (according to Perl 'trueness')
      Returns TRUE
    Else
      Returns FALSE

the true: modifiers should always be used when doing Petal conditions.


=head2 false:EXPRESSION

I'm pretty sure you can work this one out by yourself :-)


=head2 set:variable_name EXPRESSION

Sets the value returned by the evaluation of EXPRESSION in
$hash->{variable_name}. For instance:

Perl expression:

  $hash->{variable_name} = $hash->{object}->method();

Petal expression:

  set:variable_name object/method


=head2 string:STRING_EXPRESSION

The string: modifier lets you interpolate petal expressions
within a string and returns the value.

  string:Welcome $user/real_name, it is $date!

Alternatively, you could write:

  string:Welcome ${user/real_name}, it is ${date}!
  
The advantage of using curly brackets is that it lets you
interpolate expressions which invoke methods with parameters,
i.e.

  string:The current CGI 'action' param is: ${cgi/param --action}


=head1 UGLY SYNTAX

For certain things which are not doable using TAL you can use what
I call the UGLY SYNTAX. The UGLY SYNTAX is UGLY, but it can be handy
in some cases.

For example consider that you have a list of strings

    $my_var = [ 'Foo', 'Bar', 'Baz' ].
    $template->process (my_var => $my_var);


And you want to display:

  <title>Foo : Bar : Baz</title>


Which is not doable with TAL without making the XHTML invalid.
With the UGLY SYNTAX you can do:

    <title><?for name="string my_var"?> <?var name="string"?> <?end?></title>

Of course you can freely mix the UGLY SYNTAX with other Petal
syntaxes. So:

    <title><?for name="string my_var"?> $string <?end?></title>

Mind you, if you've managed to read the doc this far I must confess
that writing

    <h1>$string</h1>

instead of

    <h1 tal:replace="string">Dummy</h1>

is UGLY too. I would recommend to stick with TAL wherever you can.
But let's not disgress too much.

Petal UGLY SYNTAX is based on processing instructions. Those used to be
prefixed with 'petal:'. Since processing instructions are not meant to
support XML namespaces, this has been removed.


=head2 variables

Abstract

  <?var name="EXPRESSION"?>

Example

  <title><?var name="document/title"?></title>

Why?

Because if you don't have things which are replaced by real values
in your template, it's probably a static page, not a template :-)


=head2 if / else constructs

Usual stuff:

  <?if name="user/is_birthay"?>
    Happy Birthday, $user/real_name!
  <?else?>
    What?! It's not your birthday?
    A very merry unbirthday to you! 
  <?end?>

You can use 'condition' instead of 'if', and indeed you
can use modifiers:

  <?condition name="false:user/is_birthay"?>
    What?! It's not your birthday?
    A very merry unbirthday to you! 
  <?else?>
    Happy Birthday, $user/real_name!
  <?end?>

Not much else to say!


=head2 loops

Use either for, foreach, loop or repeat. They're all the same thing,
which one you use is a matter of taste. Again no surprise:

  <h1>Listing of user logins</h1>
  <ul>
    <?repeat name="user system/list_users"?>
      <li><?var name="user/login"?> :
          <?var name="user/real_name"?></li>
    <?end?>
  </ul>
  

Variables are scoped inside loops so you don't risk to erase an existing
'user' variable which would be outside the loop. The template engine
also provides the following variables for you inside the loop:

  <?repeat name="foo bar"?>
    <?var name="__count__"?>    - iteration number, starting at 1
    <?var name="__is_first__"?> - is it the first iteration
    <?var name="__is_last__"?>  - is it the last iteration
    <?var name="__is_inner__"?> - is it not the first and not the last iteration
    <?var name="__even__ "?>    - is the count even
    <?var name="__odd__"?>      - is the count odd
  <?end?>


Again these variables are scoped, you can safely nest loops, ifs etc...
as much as you like and everything should be fine. And if it's not,
it's a bug :-)


=head2 includes

The XInclude syntax should be preferred over this...

  <?include file="include.xml"?>

And it will include the file 'include.xml', using the current object
base_dir attribute. Petal includes occur at RUN TIME. That means that
there is NO SUPPORT to prevent infinite includes, which is usually not
so much of a deal since they happen at run time...

This should let you build templates which have a recursive behavior
which can be useful to apply templates to any tree-shaped structure (i.e.
sitemaps, threads, etc).

If you want use XML::Parser to include files, you should make sure that
the included files are valid XML themselves... FYI XML::Parser chokes on
this:

<p>foo</p>
<p>bar</p>

But this works:

<div>
  <p>foo</p>
  <p>bar</p>
</div>

(having only one top element is part of the XML spec).


=head1 ADVANCED PETAL


=head2 writing your own modifiers

Petal lets you write your own modifiers, either using coderefs
or modules.


=head3 with coderefs...

Let's say that you want to write an uppercase: modifier, which
would uppercase the result of an expression evaluation, as in:

  uppercase:string:Hello, World

Would return

  HELLO, WORLD

Here is what you can do:

  # don't forget the colon!!
  $Petal::Hash::MODIFIERS->{'uppercase:'} = sub {
      my $hash = shift;
      my $args = shift;
      my $result = $hash->fetch ($args);
      return uc ($result);
  };


=head3 ...or modules.

For quite big modifiers, you might want to use a module rather
than a coderef. Here is the example above reimplemented as a
module:

    package Petal::Hash::UpperCase;
    use strict;
    use warnings;
  
    sub process {
      my $class = shift;
      my $hash  = shift;
      my $args  = shift;

      my $result = $hash->fetch ($args);
      return uc ($result);
    }

    1;

As long as your module is in the namespace Petal::Hash::<SomeThing>,
Petal will automatically pick it up and assign it to its lowercased
name, i.e. in our example 'lowercase:'.

If your modifier is OUTSIDE Petal::Hash::<SomeThing>, you need to
make Petal aware of its existence as follows:

  use MyPetalModifier::UpperCase;
  $Petal::Hash::MODIFIERS->{'uppercase:'} = 'MyPetalModifier::UpperCase';


=head1 Expression keywords


=head2 XML encoding / structure keyword

By default Petal will encode &, <, > and " to &amp; &lt;, &gt and &quot;
respectively. However sometimes you might want to display an expression which
is already encoded, in which case you can use the 'structure' keyword.

  structure my/encoded/variable


=head2 Petal::Hash caching and fresh keyword 

Petal caches the expressions which it resolves, i.e. if you write the
expression:

  string:$foo/bar, ${baz/buz/blah}

Petal::Hash will compute it once, and then for subsequent accesses to that
expression always return the same value. This is almost never a problem, even
for loops because a new Petal::Hash object is used for each iteration in order
to support proper scoping.

However, in some rare cases you might not want to have that behavior, in which
case you need to prefix your expression with the 'fresh' keyword, i.e. 

  fresh string:$foo/bar, ${baz/buz/blah}

You can use 'fresh' with 'structure' if you need to:

  fresh structure string:$foo/bar, ${baz/buz/blah}

However the reverse does not work:

  <!-- VERY BAD, WON'T WORK !!! -->
  structure fresh string:$foo/bar, ${baz/buz/blah}


=head2 warning and errors

./lib/Petal/Hash.pm:        warn "Cannot open directory $dir. Reason: $!";
./lib/Petal/Hash.pm:        $@ and warn "Cannot import module $module. Reason: $@";
./lib/Petal/Hash.pm:    warn "Petal modifier encode: is deprecated";
./lib/Petal/Hash/Var.pm:            my $warnstr = "Cannot find value for $argument: $next cannot be retrieved\n";
./lib/Petal/Hash/Var.pm:            $warnstr .= "(current value was ";
./lib/Petal/Hash/Var.pm:            $warnstr .= (defined $current) ? "'$current'" : 'undef';
./lib/Petal/Hash/Var.pm:            $warnstr .= ")";
./lib/Petal/Hash/Var.pm:            confess $warnstr;
./blib/lib/Petal/Hash/Var.pm:       my $warnstr = "Cannot find value for $argument: $next cannot be retrieved\n";
./blib/lib/Petal/Hash/Var.pm:       $warnstr .= "(current value was ";
./blib/lib/Petal/Hash/Var.pm:       $warnstr .= (defined $current) ? "'$current'" : 'undef';
./blib/lib/Petal/Hash/Var.pm:       $warnstr .= ")";
./blib/lib/Petal/Hash/Var.pm:       confess $warnstr;
./blib/lib/Petal/Hash.pm:           warn "Cannot open directory $dir. Reason: $!";
./blib/lib/Petal/Hash.pm:           $@ and warn "Cannot import module $module. Reason: $@";
./blib/lib/Petal/Hash.pm:    warn "Petal modifier encode: is deprecated";
./Makefile:# Here we warn users that an old packlist file was found somewhere,
./Makefile:-e 'system(q[$(PERLRUN) $(POD2MAN_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\047t install $$m{$$_}\n";' \
./Makefile:-e 'chmod(oct($(PERM_RW)), $$m{$$_}) or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'

=head1 EXPORT

None.


=head1 KNOWN BUGS

The XML::Parser wrapper cannot expand any other entity than &lt;, &gt; &amp;
and &quot;. Besides, I can't get it to NOT expand entities in 'Stream' mode :-(

HTML::TreeBuilder expands all entities, hence &nbsp;s are lost / converted to
whitespaces.

XML::Parser is deprecated and should be replaced by SAX handlers at some point.


=head1 AUTHOR

Copyright 2002 - Jean-Michel Hiver <jhiver@mkdoc.com> 

This module free software and is distributed under the
same license as Perl itself. Use it at your own risk.

Thanks to everybody on the list who contributed to Petal
in the form of patches, bug reports and suggestions, in
particular thanks to:

* William McKee <william@knowmad.com> for his early support,
enthusiasm, useful suggestions, patches, and bug reports.

* Sean M. Burke <sburke@cpan.org> for his kind improvements
on his HTML::TreeBuilder module which tremendously helped
with HTML parsing.

* Kurt Stephens <kstep@pepsdesign.com> for his truly amazing
bug reports.

And everyone else I forgot :-)


=head1 SEE ALSO

Join the Petal mailing list:

  http://lists.webarch.co.uk/mailman/listinfo/petal

Mailing list archives:

  http://lists.webarch.co.uk/pipermail/petal


Have a peek at the TAL / TALES / METAL specs:

  http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL
  http://www.zope.org/Wikis/DevSite/Projects/ZPT/TALES
  http://www.zope.org/Wikis/DevSite/Projects/ZPT/METAL


Any extra questions? jhiver@mkdoc.com.
